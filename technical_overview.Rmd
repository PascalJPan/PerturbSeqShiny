---
title: "perturbSeq_shiny – Technical Overview"
author: "Pascal"
date: "2025-10-21"
output: html_document
---

## Introduction

This document provides a **technical overview** of the `perturbSeq_shiny` application.
It describes the app architecture, folder structure, reactivity patterns, performance features, and design conventions.

> **Note:**
> Always start the app from a **clean R session** via:
>
> ```r
> source("app.R")
> ```
>
> All required packages are loaded in `app.R`.

---

## Folder Structure

```

perturbSeq_shiny/
├── app.R
├── data/
│   ├── TF_lists/
│   ├── enrichment/
│   ├── knockdown_efficiency/
│   ├── expression/
│   ├── dream_output/
│   └── ...
├── R/
│   ├── helper/           # Standalone helpers (formatting, plotting, logic)
│   ├── server/           # Server modules (one per tab)
│   ├── ui/               # UI definitions (early tabs or shared UIs)
│   ├── style/            # Style + reusable UI components
│   └── setup/            # Preprocessing scripts to generate cached RDS files
└── www/
    └── pngs/             # Static images (species headers, icons)

```

### Folder roles

* **`app.R`** – main entry; sources all files and defines global UI + server.
* **`R/helper/`** – plotting functions, formatting, analysis helpers, etc.
* **`R/server/`** – one module per biological topic/tab (e.g., `conservation_server.R`).
* **`R/ui/`** – modular UIs for early tabs or shared UI fragments.
* **`R/style/`** – reusable UI helpers (e.g., `section_header()`, `styled_plot()`).
* **`R/setup/`** – **precompute** heavy artifacts to speed up app load & enforce logic:

  * *Permutation preprocessing*: scripts that summarize permutation results and save `RDS` for use by Conservation/Permutation modules.
  * *TF filtering information*: script that creates `TF_filter_information.rds`, defining which TFs are shown/hidden where (critical gating logic).
* **`www/`** – static resources (e.g., `Human.png`, `Cynomolgus.png`).
* **`data/`** – preprocessed `.rds` objects (TF lists, expression, enrichment, DREAM outputs, …).

---

## App Architecture

The app is a **modular Shiny application**.

### Initialization

* `app.R` loads packages, defines colors, sources all `R/ui`, `R/server`, `R/helper`, `R/style`.
* Global colors:

```r
colors_app <- list(
  human      = "#C91C52",
  cynomolgus = "#009E9A",
  TF         = "#D62728",
  DR         = "#FFC300"
)
```

### Lazy Module Loader

Each tab’s server logic is initialized **only when its tab becomes active**:

```r
smart_tab_loader <- function(input, tab_id, module_id, server_fn, ...) {
  loaded <- shiny::reactiveVal(FALSE)
  is_active <- shiny::reactive({ input$tabs == tab_id })
  shiny::observe({
    if (is_active() && !loaded()) {
      server_fn(id = module_id, ..., is_active = is_active)
      loaded(TRUE)
    }
  })
}
```

### Module List (examples)

```
tf_characteristics_server.R
grna_characteristics_server.R
expression_server.R
knockdown_efficiency_server.R
enrichment_server.R
stemness_server.R
DE_DR_DT_analysis_server.R
conservation_server.R
permutation_server.R
```

---

## Reactive Design & Optimization

### Shared Reactivity

* `selected_tf` is global and passed into modules.
* Each module also receives `is_active()` so hidden tabs don’t recompute.

### TF Latching

Modules keep the **last shown TF** while the tab is active:

```r
last_tf_shown <- reactiveVal(NULL)
observeEvent(list(selected_tf(), is_active()), {
  req(is_active())
  tf <- selected_tf()
  if (!identical(tf, last_tf_shown())) last_tf_shown(tf)
}, ignoreInit = FALSE)
current_tf <- reactive({ req(last_tf_shown()); last_tf_shown() })
```

### Conditional Rendering (Gating)

Modules consult `TF_filter_information.rds` to decide if plots should render:

```r
output$content <- renderUI({
  if (!show_plots()) {
    div(class="p-4", h3("This TF is filtered out"), p(filter_message()))
  } else {
    tagList( ... ) # full body
  }
})
```

### Caching

Use `bindCache(current_tf())` for plot/table outputs to speed up TF switching.

### Performance Controls

Expensive tasks (e.g., GO terms, Gviz) run on **explicit button clicks** to avoid unnecessary computation.

---

## Design & User Interface

### Layout

* Sticky header with TF selector, debug/screenshot actions, species images.
* `tabsetPanel()` for each analysis section.

### CSS & Styling

* Global CSS lives in `<head>` within `app.R` plus helpers in `R/style/`.
* Principles:

  * Responsive down to typical 13” screens.
  * Consistent color palette (`colors_app`).
  * Plotly for exploration; ggplot2 where performance matters.

### Plot Conventions

* Plotly with tooltips/hover where helpful.
* Static ggplot for heavy histograms/violin/beeswarm where speed matters.
* Consistent species labeling via `species_header()` / `section_header()` helpers.

---

## Info Buttons (Bottom-Sheet Help)

The app uses a **global bottom sheet** (`info_sheet_ui()`) and **per-module info buttons** (`actionButton`) to show contextual help.

### 1) Bottom sheet included in global UI

In `app.R`:

```r
useShinyjs()
info_sheet_ui(
  background_color_button = colors_app$cynomolgus,   # button background
  text_color_button       = "#ffffff",               # button text/icon
  sheet_shadow_color      = "rgba(0,158,154,0.25)"   # shadow with transparency
)
```

### 2) Add a new info button (UI)

Inside any module UI / `renderUI`:

```r
info_button_right(ns, "my_info_btn") 
```
"my_info_btn" is the identifier which needs to be different for all info buttons.

### 3) Show the sheet on click (Server)

**Plain text:**

```r
observeEvent(input$my_info_btn, {
  session$sendCustomMessage("show-info-sheet", list(
    title = "About this panel",
    text  = "Short explanation of what the panel shows."
  ))
})
```

**HTML content:**

```r
observeEvent(input$my_info_btn, {
  session$sendCustomMessage("show-info-sheet", list(
    title = "About this panel",
    html  = "<p><b>Tip:</b> Hover points for values.<br>Lower is better.</p>"
  ))
})
```

### 4) Optional helper to avoid repetition

If you included a helper like:

```r
info_button_bind <- function(session, input, btn_id, title, text = NULL, html = NULL) {
  observeEvent(input[[btn_id]], {
    payload <- list(title = title)
    if (!is.null(html)) payload$html <- if (is.function(html)) html() else html
    if (!is.null(text)) payload$text <- if (is.function(text)) text() else text
    session$sendCustomMessage("show-info-sheet", payload)
  }, ignoreInit = TRUE)
}
```

…then call:

```r
info_button_bind(
  session, input,
  btn_id = "my_info_btn",
  title  = "About this panel",
  html   = "<p>Custom <i>HTML</i> here.</p>"
)
```

### 5) Changing colors

* **Global palette** in `app.R`:

```r
colors_app <- list(
  human      = "#C91C52",
  cynomolgus = "#009E9A",
  TF         = "#D62728",
  DR         = "#FFC300"
)
```

## Data Dependencies & Setup Scripts (`R/setup/`)

These scripts **precompute** artifacts to speed up the app and define availability logic:

* **Permutation preprocessing**

  * Aggregates permutation results (e.g., distributions, summary stats).
  * Saves RDS outputs used by Conservation/Permutation modules to avoid recomputing on app load.

* **TF filtering information**

  * Generates `data/TF_lists/TF_filter_information.rds`.
  * Encodes which TFs are available in which modules and why others are filtered.
  * This file is **required** for the gating logic that decides whether a module shows plots or a “TF filtered out” message.

> Re-run these scripts whenever underlying raw data changes, then restart the app.

---

## Development Notes

* Prefer `shiny::tags` instead of bare `tags`.
* GO analysis thresholds (example defaults):

  * ≥10 background genes annotated
  * ≥2 list hits
    (adjustable in `go_analysis_smart()`).
* UIs after `grna_characteristics` are often generated via `renderUI()` inside their modules.
* Heavy objects are loaded once (globally) and reused.
* Debugging:

  * **Debug** button prints `str(reactiveValuesToList(input))`.
  * **Screenshot** via `shinyscreenshot::screenshot()`.

---

## Next Steps

* Continue permutation analysis.
* Do checks to ensure permutation results are reasonable and reliable.
* Decide on **one** conservation metric; remove unnecessary metrics and filtering options from the app.
* Remove the **Debug** button before publishing.
* Add information buttons in all necessary locations (right-aligned, with concise help text/HTML).

---
